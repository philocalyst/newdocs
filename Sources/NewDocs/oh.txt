import Foundation

actor RateLimiter {
  private let limit: Int
  private var timestamps: [Date] = []

  init(limit: Int) {
    self.limit = limit
  }

  func waitIfNeeded() async {
    let now = Date()
    let oneMinuteAgo = now.addingTimeInterval(-60)

    // Remove old timestamps
    timestamps.removeAll { $0 <= oneMinuteAgo }

    if timestamps.count >= limit, let oldest = timestamps.first {
      let waitTime = 60 - now.timeIntervalSince(oldest) + 1
      if waitTime > 0 {
        try? await Task.sleep(nanoseconds: UInt64(waitTime * 1_000_000_000))
      }
    }

    timestamps.append(now)
  }
}
import Alamofire
import Foundation
import Logging

public protocol HTTPRequesting {
  func request(
    _ url: String,
    method: HTTPMethod,
    parameters: [String: Any]?,
    headers: HTTPHeaders?
  ) async throws -> HTTPResponse
}

extension HTTPRequesting {
  public func request(_ url: String) async throws -> HTTPResponse {
    return try await request(url, method: .get, parameters: nil, headers: nil)
  }
}

public struct HTTPRequest: HTTPRequesting, Instrumentable {
  public let logger: Logger
  private let session: Session

  public init(logger: Logger = Logger(label: "HTTPRequest")) {
    self.logger = logger
    self.session = Session()
  }

  public func request(
    _ url: String,
    method: HTTPMethod = .get,
    parameters: [String: Any]? = nil,
    headers: HTTPHeaders? = nil
  ) async throws -> HTTPResponse {
    return try await instrument("http_request", metadata: ["url": url]) {
      return try await withCheckedThrowingContinuation { continuation in
        session.request(
          url,
          method: method,
          parameters: parameters,
          headers: headers
        ).responseData { response in
          switch response.result {
          case .success(let data):
            let httpResponse = HTTPResponse(
              url: response.request?.url?.absoluteString ?? url,
              statusCode: response.response?.statusCode ?? 0,
              headers: response.response?.allHeaderFields as? [String: String] ?? [:],
              data: data
            )
            continuation.resume(returning: httpResponse)
          case .failure(let error):
            continuation.resume(throwing: DocsError.networkError(error.localizedDescription))
          }
        }
      }
    }
  }
}

public struct HTTPResponse {
  public let url: String
  public let statusCode: Int
  public let headers: [String: String]
  public let data: Data

  public var body: String {
    return String(data: data, encoding: .utf8) ?? ""
  }

  public var isSuccess: Bool {
    return statusCode == 200
  }

  public var isError: Bool {
    return statusCode == 0
      || (statusCode >= 400 && statusCode <= 599 && statusCode != 404 && statusCode != 403)
  }

  public var isEmpty: Bool {
    return data.isEmpty
  }

  public var contentLength: Int {
    return Int(headers["Content-Length"] ?? "0") ?? 0
  }

  public var mimeType: String {
    return headers["Content-Type"] ?? "text/plain"
  }

  public var isHTML: Bool {
    return mimeType.contains("html")
  }

  public func asJSON() throws -> [String: Any] {
    return try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
  }
}
// Implements a tracing-like API for measuring and analyzing asynchronus operations.
// This activates and ends automagically !

import Foundation
import Logging

public protocol Instrumentable {
  var logger: Logger { get }
}

extension Instrumentable {
  public func instrument<T>(
    _ operationName: String,
    metadata: [String: Any]? = nil,
    operation: () async throws -> T
  ) async rethrows -> T {
    let start = Date()
    logger.info("Starting \(operationName)", metadata: Logger.Metadata(metadata ?? [:]))

    do {
      let result = try await operation()
      let duration = Date().timeIntervalSince(start)
      logger.info("Completed \(operationName) in \(duration)s")
      return result
    } catch {
      let duration = Date().timeIntervalSince(start)
      logger.error("Failed \(operationName) after \(duration)s: \(error)")
      throw error
    }
  }
}

extension Logger.Metadata {
  init(_ dictionary: [String: Any]) {
    self.init()
    for (key, value) in dictionary {
      self[key] = Logger.MetadataValue(stringLiteral: String(describing: value))
    }
  }
}
import Foundation

public protocol EntryIndexing {
  var isEmpty: Bool { get }
  var count: Int { get }

  mutating func add(_ entry: Entry)
  mutating func add(_ entries: [Entry])
  func asJSON() -> [String: Any]
  func toJSON() throws -> Data
}

public struct EntryIndex: EntryIndexing {
  private var entries: Set<Entry> = []

  public init() {}

  public var isEmpty: Bool {
    return entries.isEmpty
  }

  public var count: Int {
    return entries.count
  }

  public mutating func add(_ entry: Entry) {
    guard !entry.isRoot else { return }
    entries.insert(entry)
  }

  public mutating func add(_ entries: [Entry]) {
    for entry in entries {
      guard !entry.isRoot else { continue }
      self.entries.insert(entry)
    }
  }

  public func asJSON() -> [String: Any] {
    // Sort the entries by their names
    let sortedEntries = entries.sorted { a, b in
      sortNames(a.name, b.name)
    }

    // Build the types map, and enforce conversion to DocType. Where each key (Name) corresponds to a DocType
    let typesMap: [String: DocType] = Dictionary(grouping: sortedEntries, by: \.type)
      .mapValues { group in
        DocType(name: group[0].type, count: group.count)
      }

    // Convert to JSON and sort the types by names
    let sortedTypesJSON = typesMap.values
      .sorted { sortNames($0.name, $1.name) }
      .map { $0.asJSON() }

    return [
      "entries": sortedEntries.map { $0.asJSON() },
      "types": sortedTypesJSON,
    ]
  }

  public func toJSON() throws -> Data {
    return try JSONSerialization.data(
      withJSONObject: asJSON(),
      options: .prettyPrinted
    )
  }

  private func sortNames(_ a: String, _ b: String) -> Bool {
    let aFirstByte = a.first?.asciiValue ?? 0
    let bFirstByte = b.first?.asciiValue ?? 0

    let aIsDigit = (49...57).contains(aFirstByte)
    let bIsDigit = (49...57).contains(bFirstByte)

    if aIsDigit || bIsDigit {
      let aSplit = a.components(separatedBy: CharacterSet(charactersIn: ".-"))
      let bSplit = b.components(separatedBy: CharacterSet(charactersIn: ".-"))

      if aSplit.count == 1 && bSplit.count == 1 {
        return a.localizedCaseInsensitiveCompare(b) == .orderedAscending
      }
      if aSplit.count == 1 { return false }
      if bSplit.count == 1 { return true }

      return a.localizedCaseInsensitiveCompare(b) == .orderedAscending
    } else {
      return a.localizedCaseInsensitiveCompare(b) == .orderedAscending
    }
  }
}
// Contains the logic for the storing... Docs!! This is going to handle the composition
// Of all of the important doc information... think index, meta, and content, into the
// formats they're expected to be.

import Foundation
import Logging

public protocol DocStorerProtocol {
  func store(_ doc: Doc, to store: DocumentStore) async throws
}

/// The default implementation for doc storage
public struct DocStorer: DocStorerProtocol {
  private let logger: Logger

  public init(logger: Logger = Logger(label: "DocStorer")) {
    self.logger = logger
  }

  public func store(_ doc: Doc, to store: DocumentStore) async throws {
    // Get empty (mutable) stores to build on top of :)
    var index = EntryIndex()
    var pages = PageDatabase()

    // Process all pages
    for await page in doc.buildPages() {
      try await store.write(page.storePath, content: page.output)
      index.add(page.entries)
      pages.add(path: page.path, content: page.output)
    }

    // Write index.json
    let indexData = try index.toJSON()
    try await store.write(doc.indexPath, data: indexData)

    // Write db.json
    let dbData = try pages.toJSON()
    try await store.write(doc.dbPath, data: dbData)

    // Write meta.json
    var meta = doc.asJSON()
    meta["mtime"] = Int(Date().timeIntervalSince1970)
    meta["db_size"] = try await store.size(doc.dbPath)
    let metaData = try JSONSerialization.data(withJSONObject: meta, options: .prettyPrinted)
    try await store.write(doc.metaPath, data: metaData)

    logger.info("Successfully stored doc: \(doc.slug)")
  }
}
// Sources/NewDocs/Storage/DocumentStore.swift
// VERY GENERIC storage, designed to be interacted with through the docstorer, which handles the actual document-specific writing...

import Foundation

public protocol DocumentStore {
  func write(_ path: String, content: String) async throws
  func write(_ path: String, data: Data) async throws
  func read(_ path: String) async throws -> String
  func exists(_ path: String) async -> Bool
  func size(_ path: String) async throws -> Int
  func delete(_ path: String) async throws
  func list(_ directory: String) async throws -> [String]
}

public struct FileSystemStore: DocumentStore {
  private let baseDirectory: URL

  public init(baseDirectory: String) throws {
    self.baseDirectory = URL(fileURLWithPath: baseDirectory)
    try createDirectoryIfNeeded()
  }

  private func createDirectoryIfNeeded() throws {
    try FileManager.default.createDirectory(
      at: baseDirectory,
      withIntermediateDirectories: true,
      attributes: nil
    )
  }

  /// Convenience function to write string contents to the specified path
  public func write(_ path: String, content: String) async throws {
    try await write(path, data: content.data(using: .utf8) ?? Data())
  }

  /// Convenience function to write data to the specificed path
  public func write(_ path: String, data: Data) async throws {
    let fileURL = baseDirectory.appendingPathComponent(path)
    let directoryURL = fileURL.deletingLastPathComponent()

    // Creates directories as necessary up to the component
    try FileManager.default.createDirectory(
      at: directoryURL,
      withIntermediateDirectories: true,
      attributes: nil
    )

    try data.write(to: fileURL)
  }

  public func read(_ path: String) async throws -> String {
    let fileURL = baseDirectory.appendingPathComponent(path)
    let data = try Data(contentsOf: fileURL)
    guard let content = String(data: data, encoding: .utf8) else {
      throw DocsError.parsingError("Could not decode file as UTF-8: \(path)")
    }
    return content
  }

  public func exists(_ path: String) async -> Bool {
    let fileURL = baseDirectory.appendingPathComponent(path)
    return FileManager.default.fileExists(atPath: fileURL.path)
  }

  public func size(_ path: String) async throws -> Int {
    let fileURL = baseDirectory.appendingPathComponent(path)
    let attributes = try FileManager.default.attributesOfItem(atPath: fileURL.path)
    return (attributes[.size] as? Int) ?? 0
  }

  public func delete(_ path: String) async throws {
    let fileURL = baseDirectory.appendingPathComponent(path)
    try FileManager.default.removeItem(at: fileURL)
  }

  public func list(_ directory: String) async throws -> [String] {
    let directoryURL = baseDirectory.appendingPathComponent(directory)
    return try FileManager.default.contentsOfDirectory(atPath: directoryURL.path)
  }
}
import Foundation

public enum DocsError: Error, CustomStringConvertible {
  case setupError(String)
  case invalidEntry(String)
  case networkError(String)
  case parsingError(String)
  case fileNotFound(String)
  case invalidConfiguration(String)

  public var description: String {
    switch self {
    case .setupError(let message): return "Setup Error: \(message)"
    case .invalidEntry(let message): return "Invalid Entry: \(message)"
    case .networkError(let message): return "Network Error: \(message)"
    case .parsingError(let message): return "Parsing Error: \(message)"
    case .fileNotFound(let message): return "File Not Found: \(message)"
    case .invalidConfiguration(let message): return "Invalid Configuration: \(message)"
    }
  }
}
import Foundation
import Logging
import SwiftSoup

public protocol HTMLParsing {
  var title: String? { get }
  var document: Document { get }
}

public struct HTMLParser: HTMLParsing {
  public let title: String?
  public let document: Document

  public init(_ content: String) throws {
    // Detect if the HTML contains the full prelude string
    if content.range(
      of: #"(?i)\A(?:\s|(?:<!--.*?-->))*<(?:\!doctype|html)"#, options: .regularExpression) != nil
    {
      document = try SwiftSoup.parse(content)
      title = try document.select("title").first()?.text()
    } else {  // If not, assume it's a fragment and treat it as such.
      document = try SwiftSoup.parseBodyFragment(content)
      title = nil
    }
  }
}
import Foundation
import Logging
import SemVer

public enum OutdatedState: String, CaseIterable {
  case upToDate = "Up-to-date"
  case outdatedMinor = "Outdated minor version"
  case outdatedMajor = "Outdated major version"
}

public protocol Doc: Instrumentable {
  var name: String { get }  // The name you'd expect to see it referred to as
  var slug: String { get }  // The battle-ready slug for encoding and references
  var type: String { get }
  var version: Version? { get }  // The latest version we're aware of in the "software"
  var links: [String: URL] { get }

  func buildPages() -> AsyncStream<PageResult>
  func getLatestVersion() async throws -> String
  func getScraperVersion() async throws -> String
}

extension Doc {
  /// Returns the typical pathing for an index
  public var indexPath: String {
    return "\(slug)/index.json"
  }

  /// Returns the typical pathing for a DB
  public var dbPath: String {
    return "\(slug)/db.json"
  }

  /// Returns the typicalR pathing for the meta files
  public var metaPath: String {
    return "\(slug)/meta.json"
  }

  /// Returns the Doc as a JSONL object
  public func asJSON() -> [String: Any] {
    var json: [String: Any] = [
      "name": name,
      "slug": slug,
      "type": type,
    ]

    if !links.isEmpty {
      json["links"] = links
    }

    if let release = version {
      json["release"] = release
    }

    return json
  }

  // Utility methods for network requests
  public func fetchJSON(from urlString: String) async throws -> [String: Any] {
    let request = HTTPRequest(logger: logger)
    let response = try await request.request(urlString)
    guard response.isSuccess else {
      throw DocsError.networkError("Failed to fetch \(urlString): \(response.statusCode)")
    }
    return try response.asJSON()
  }

  public func getNPMVersion(package: String, tag: String = "latest") async throws -> String {
    let json = try await fetchJSON(from: "https://registry.npmjs.com/\(package)")
    guard let distTags = json["dist-tags"] as? [String: Any],
      let version = distTags[tag] as? String
    else {
      throw DocsError.parsingError("Could not parse npm version for \(package)")
    }
    return version
  }

  public func getLatestGitHubRelease(owner: String, repo: String) async throws -> String {
    let json = try await fetchJSON(
      // Getting the release endpoint
      from: "https://api.github.com/repos/\(owner)/\(repo)/releases/latest")
    guard let tagName = json["tag_name"] as? String else {
      throw DocsError.parsingError("Could not parse GitHub release tag")
    }
    return tagName.hasPrefix("v") ? String(tagName.dropFirst()) : tagName
  }
}
import Foundation

public protocol PageDatabaseProtocol {
  var isEmpty: Bool { get }

  mutating func add(path: String, content: String)
  func asJSON() -> [String: Any]
  func toJSON() throws -> Data
}

public struct PageDatabase: PageDatabaseProtocol {
  private var pages: [String: String] = [:]

  public init() {}

  public var isEmpty: Bool {
    return pages.isEmpty
  }

  public mutating func add(path: String, content: String) {
    pages[path] = content
  }

  public func asJSON() -> [String: Any] {
    return pages
  }

  public func toJSON() throws -> Data {
    return try JSONSerialization.data(withJSONObject: asJSON(), options: [])
  }
}
// Filtering for an HTML document, meant to be used to reduce unwanted structure.
// Think ads, nesting, etc. Basically an interface to build helpers ontop of,
// to pare down a messy document. Allows us to create simple methods that are universally useful,
// Like normalizing URLS :)

import Foundation
import Logging
import SwiftSoup

public protocol Filter {
  func apply(to document: Document, context: FilterContext) throws -> Document
}

public struct FilterContext {
  public let baseURL: DocsURL
  public let currentURL: DocsURL
  public let rootURL: DocsURL
  public let rootPath: String?
  public let links: [String: URL]
  public let initialPaths: [String]
  public let logger: Logger

  public init(
    baseURL: DocsURL,
    currentURL: DocsURL,
    rootURL: DocsURL,
    rootPath: String? = nil,
    links: [String: URL] = [:],
    initialPaths: [String] = [],
    logger: Logger = Logger(label: "Filter")
  ) {
    self.baseURL = baseURL
    self.currentURL = currentURL
    self.rootURL = rootURL
    self.rootPath = rootPath
    self.links = links
    self.initialPaths = initialPaths
    self.logger = logger
  }

  public var subpath: String {
    return baseURL.subpath(to: currentURL, ignoreCase: true) ?? ""
  }

  public var slug: String {
    let path = subpath.hasPrefix("/") ? String(subpath.dropFirst()) : subpath
    return path.replacingOccurrences(of: ".html", with: "")
  }

  public var isRootPage: Bool {
    return subpath.isEmpty || subpath == "/" || subpath == rootPath
  }

  public var isInitialPage: Bool {
    return isRootPage || initialPaths.contains(subpath)
  }
}

public protocol FilterStacking {
  mutating func push(_ filter: Filter)
  func apply(to document: Document, context: FilterContext) throws -> Document
}

public struct FilterStack: FilterStacking {
  private var filters: [Filter] = []

  public init() {}

  public mutating func push(_ filter: Filter) {
    filters.append(filter)
  }

  public func apply(to document: Document, context: FilterContext) throws -> Document {
    var currentDocument = document
    for filter in filters {
      currentDocument = try filter.apply(to: currentDocument, context: context)
    }
    return currentDocument
  }
}
import Foundation

public struct DocsURL: Equatable, Hashable {
  public let url: URL

  public init(_ string: String) throws {
    guard let url = URL(string: string) else {
      throw DocsError.invalidConfiguration("Invalid URL: \(string)")
    }
    self.url = url
  }

  public init(_ url: URL) {
    self.url = url
  }

  public var origin: String? {
    guard let scheme = url.scheme, let host = url.host else { return nil }
    var origin = "\(scheme)://\(host)"
    if let port = url.port {
      origin += ":\(port)"
    }
    return origin
  }

  public var normalizedPath: String {
    return url.path.isEmpty ? "/" : url.path
  }

  public func subpath(to other: DocsURL, ignoreCase: Bool = false) -> String? {
    guard origin == other.origin else { return nil }

    let basePath = ignoreCase ? url.path.lowercased() : url.path
    let destPath = ignoreCase ? other.url.path.lowercased() : other.url.path

    if basePath == destPath {
      return ""
    } else if destPath.hasPrefix(basePath + "/") {
      return String(other.url.path.dropFirst(url.path.count))
    }
    return nil
  }

  public func contains(_ other: DocsURL, ignoreCase: Bool = false) -> Bool {
    return subpath(to: other, ignoreCase: ignoreCase) != nil
  }

  public func joining(_ path: String) -> DocsURL {
    let newURL = url.appendingPathComponent(path)
    return DocsURL(newURL)
  }
}

extension DocsURL: CustomStringConvertible {
  public var description: String {
    return url.absoluteString
  }
}
import Foundation

public struct ScraperOptions {
  public var skip: [String]
  public var skipPatterns: [NSRegularExpression]
  public var only: [String]
  public var onlyPatterns: [NSRegularExpression]
  public var skipLinks: [String]
  public var fixedInternalUrls: Bool
  public var redirections: [String: String]
  public var rateLimit: Int?
  public var maxConcurrency: Int
  public var timeout: TimeInterval
  public var retryCount: Int
  public var fixURLs: ((String) -> String)?
  public var attribution: String?
  public var version: String?
  public var release: String?
  public var links: [String: String]

  public init(
    skip: [String] = [],
    skipPatterns: [NSRegularExpression] = [],
    only: [String] = [],
    onlyPatterns: [NSRegularExpression] = [],
    skipLinks: [String] = [],
    fixedInternalUrls: Bool = false,
    redirections: [String: String] = [:],
    rateLimit: Int? = nil,
    maxConcurrency: Int = 20,
    timeout: TimeInterval = 30,
    retryCount: Int = 3,
    fixURLs: ((String) -> String)? = nil,
    attribution: String? = nil,
    version: String? = nil,
    release: String? = nil,
    links: [String: String] = [:]
  ) {
    self.skip = skip
    self.skipPatterns = skipPatterns
    self.only = only
    self.onlyPatterns = onlyPatterns
    self.skipLinks = skipLinks
    self.fixedInternalUrls = fixedInternalUrls
    self.redirections = redirections
    self.rateLimit = rateLimit
    self.maxConcurrency = maxConcurrency
    self.timeout = timeout
    self.retryCount = retryCount
    self.fixURLs = fixURLs
    self.attribution = attribution
    self.version = version
    self.release = release
    self.links = links
  }
}
import Foundation
import Logging
import SwiftSoup

public enum ScraperSource {
  case local(directory: URL)
  case remote(
    rateLimit: Int? = nil,
    headers: [String: String] = ["User-Agent": "NewDocs"],
    params: [URLQueryItem] = [],
    forceGzip: Bool = false
  )
}

public protocol Scraper: Doc {
  var baseURL: DocsURL { get }
  var rootURL: DocsURL { get }
  var rootPath: String? { get }
  var initialPaths: [String] { get }
  var options: ScraperOptions { get }
  var source: ScraperSource { get }
  var htmlFilters: FilterStack { get }
  var textFilters: FilterStack { get }

  /// Primitive you must implement
  func fetch(_ url: String) async throws -> HTTPResponse

  func extractEntries(
    from document: Document,
    context: FilterContext
  ) throws -> [Entry]

  /// Default‐overrideable hooks
  func shouldProcessResponse(_ response: HTTPResponse) -> Bool
  func preprocessResponse(_ response: HTTPResponse) -> HTTPResponse
}

extension Scraper {
  /// Compute your full URLs from the configured sub‐paths
  public var initialURLs: [String] {
    var urls = [rootURL.description]
    urls.append(contentsOf: initialPaths.map { urlFor(path: $0) })
    return urls
  }

  public func urlFor(path: String) -> String {
    if path.isEmpty || path == "/" {
      return rootURL.description
    } else {
      return baseURL.joining(path).description
    }
  }

  /// Default: no extra preprocessing
  public func preprocessResponse(_ response: HTTPResponse) -> HTTPResponse {
    response
  }

  /// Default: semver + HTML + same‐origin
  public func shouldProcessResponse(_ response: HTTPResponse) -> Bool {
    guard response.isSuccess && response.isHTML else { return false }
    guard let u = try? DocsURL(response.url),
      baseURL.contains(u)
    else {
      return false
    }
    return true
  }

  /// The single stream of pages, run *sequentially* to avoid capturing `inout`
  public func buildPages() -> AsyncStream<PageResult> {
    AsyncStream<PageResult>(bufferingPolicy: .unbounded) { continuation in
      Task {
        var seen = Set<String>()
        var queue = initialURLs

        while !queue.isEmpty {
          let path = queue.removeFirst()
          let key = path.lowercased()
          guard seen.insert(key).inserted else { continue }

          do {
            let raw = try await fetch(path)
            let response = preprocessResponse(raw)
            guard shouldProcessResponse(response) else { continue }

            let page = try await processResponse(response)
            continuation.yield(page)

            // enqueue newly discovered URLs
            for next in page.internalURLs {
              let lower = next.lowercased()
              if seen.insert(lower).inserted {
                queue.append(next)
              }
            }
          } catch {
            logger.error("Error scraping \(path): \(error)")
          }
        }

        continuation.finish()
      }
    }
  }

  /// Shared logic to turn an HTTPResponse → PageResult
  private func processResponse(_ response: HTTPResponse) async throws
    -> PageResult
  {
    let parser = try HTMLParser(response.body)
    let context = FilterContext(
      baseURL: baseURL,
      currentURL: try DocsURL(response.url),
      rootURL: rootURL,
      rootPath: rootPath,
      links: links,
      initialPaths: initialPaths,
      logger: logger
    )

    // 1) run your HTML filters
    let htmlDoc = try htmlFilters.apply(to: parser.document, context: context)
    // 2) run your text filters (they can pluck out entries, internalURLs, etc.)
    let finalDoc = try textFilters.apply(to: htmlDoc, context: context)

    // 3) extract the results
    let entries = try extractEntries(from: finalDoc, context: context)
    let internalURLs = try extractInternalURLs(from: finalDoc)

    return PageResult(
      path: context.subpath,
      storePath: context.slug,
      output: try finalDoc.html(),
      entries: entries,
      internalURLs: internalURLs
    )
  }

  /// Default no‐op: filters should build up your entries in the pipeline data
  private func extractEntries(from document: Document, context: FilterContext)
    throws -> [Entry]
  {
    return []
  }

  private func extractInternalURLs(from document: Document) throws -> [String] {
    let aTags = try document.select("a[href]").array()
    return try aTags.compactMap { a in
      let href = try a.attr("href")
      guard !href.isEmpty, isInternalURL(href) else { return nil }
      return href
    }
  }

  private func isInternalURL(_ url: String) -> Bool {
    return !url.hasPrefix("http")
      && !url.hasPrefix("#")
      && !url.hasPrefix("data:")
  }
}
import Foundation

public struct PageResult {
  public let path: String
  public let storePath: String
  public let output: String
  public let entries: [Entry]
  public let internalURLs: [String]

  public init(
    path: String,
    storePath: String,
    output: String,
    entries: [Entry],
    internalURLs: [String] = []
  ) {
    self.path = path
    self.storePath = storePath
    self.output = output
    self.entries = entries
    self.internalURLs = internalURLs
  }
}
// Represents one kind of documentation entry, whether that be a class, method, etc.
// Sort of generalizable, which is why the name is encoded as a string. (But I'm thinking of changing this)
// Count is just the number of times we've seen this doctype relative to a particular doc
import Foundation

public struct DocType: Codable, Equatable, Hashable {
  public let name: String
  public var count: Int

  public init(name: String, count: Int = 0) {
    self.name = name
    self.count = count
  }

  public var slug: String {
    return name.lowercased()
      .replacingOccurrences(of: " ", with: "-")
      .replacingOccurrences(of: "[^a-z0-9-]", with: "", options: .regularExpression)
  }

  public func asJSON() -> [String: Any] {
    return [
      "name": name,
      "count": count,
      "slug": slug,
    ]
  }
}
import Foundation

actor RateLimiter {
  private let limit: Int
  private var timestamps: [Date] = []

  init(limit: Int) {
    self.limit = limit
  }

  func waitIfNeeded() async {
    let now = Date()
    let oneMinuteAgo = now.addingTimeInterval(-60)

    // Remove old timestamps
    timestamps.removeAll { $0 <= oneMinuteAgo }

    if timestamps.count >= limit, let oldest = timestamps.first {
      let waitTime = 60 - now.timeIntervalSince(oldest) + 1
      if waitTime > 0 {
        try? await Task.sleep(nanoseconds: UInt64(waitTime * 1_000_000_000))
      }
    }

    timestamps.append(now)
  }
}
import Alamofire
import Foundation
import Logging

public protocol HTTPRequesting {
  func request(
    _ url: String,
    method: HTTPMethod,
    parameters: [String: Any]?,
    headers: HTTPHeaders?
  ) async throws -> HTTPResponse
}

extension HTTPRequesting {
  public func request(_ url: String) async throws -> HTTPResponse {
    return try await request(url, method: .get, parameters: nil, headers: nil)
  }
}

public struct HTTPRequest: HTTPRequesting, Instrumentable {
  public let logger: Logger
  private let session: Session

  public init(logger: Logger = Logger(label: "HTTPRequest")) {
    self.logger = logger
    self.session = Session()
  }

  public func request(
    _ url: String,
    method: HTTPMethod = .get,
    parameters: [String: Any]? = nil,
    headers: HTTPHeaders? = nil
  ) async throws -> HTTPResponse {
    return try await instrument("http_request", metadata: ["url": url]) {
      return try await withCheckedThrowingContinuation { continuation in
        session.request(
          url,
          method: method,
          parameters: parameters,
          headers: headers
        ).responseData { response in
          switch response.result {
          case .success(let data):
            let httpResponse = HTTPResponse(
              url: response.request?.url?.absoluteString ?? url,
              statusCode: response.response?.statusCode ?? 0,
              headers: response.response?.allHeaderFields as? [String: String] ?? [:],
              data: data
            )
            continuation.resume(returning: httpResponse)
          case .failure(let error):
            continuation.resume(throwing: DocsError.networkError(error.localizedDescription))
          }
        }
      }
    }
  }
}

public struct HTTPResponse {
  public let url: String
  public let statusCode: Int
  public let headers: [String: String]
  public let data: Data

  public var body: String {
    return String(data: data, encoding: .utf8) ?? ""
  }

  public var isSuccess: Bool {
    return statusCode == 200
  }

  public var isError: Bool {
    return statusCode == 0
      || (statusCode >= 400 && statusCode <= 599 && statusCode != 404 && statusCode != 403)
  }

  public var isEmpty: Bool {
    return data.isEmpty
  }

  public var contentLength: Int {
    return Int(headers["Content-Length"] ?? "0") ?? 0
  }

  public var mimeType: String {
    return headers["Content-Type"] ?? "text/plain"
  }

  public var isHTML: Bool {
    return mimeType.contains("html")
  }

  public func asJSON() throws -> [String: Any] {
    return try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
  }
}
// Implements a tracing-like API for measuring and analyzing asynchronus operations.
// This activates and ends automagically !

import Foundation
import Logging

public protocol Instrumentable {
  var logger: Logger { get }
}

extension Instrumentable {
  public func instrument<T>(
    _ operationName: String,
    metadata: [String: Any]? = nil,
    operation: () async throws -> T
  ) async rethrows -> T {
    let start = Date()
    logger.info("Starting \(operationName)", metadata: Logger.Metadata(metadata ?? [:]))

    do {
      let result = try await operation()
      let duration = Date().timeIntervalSince(start)
      logger.info("Completed \(operationName) in \(duration)s")
      return result
    } catch {
      let duration = Date().timeIntervalSince(start)
      logger.error("Failed \(operationName) after \(duration)s: \(error)")
      throw error
    }
  }
}

extension Logger.Metadata {
  init(_ dictionary: [String: Any]) {
    self.init()
    for (key, value) in dictionary {
      self[key] = Logger.MetadataValue(stringLiteral: String(describing: value))
    }
  }
}
import Foundation

public protocol EntryIndexing {
  var isEmpty: Bool { get }
  var count: Int { get }

  mutating func add(_ entry: Entry)
  mutating func add(_ entries: [Entry])
  func asJSON() -> [String: Any]
  func toJSON() throws -> Data
}

public struct EntryIndex: EntryIndexing {
  private var entries: Set<Entry> = []

  public init() {}

  public var isEmpty: Bool {
    return entries.isEmpty
  }

  public var count: Int {
    return entries.count
  }

  public mutating func add(_ entry: Entry) {
    guard !entry.isRoot else { return }
    entries.insert(entry)
  }

  public mutating func add(_ entries: [Entry]) {
    for entry in entries {
      guard !entry.isRoot else { continue }
      self.entries.insert(entry)
    }
  }

  public func asJSON() -> [String: Any] {
    // Sort the entries by their names
    let sortedEntries = entries.sorted { a, b in
      sortNames(a.name, b.name)
    }

    // Build the types map, and enforce conversion to DocType. Where each key (Name) corresponds to a DocType
    let typesMap: [String: DocType] = Dictionary(grouping: sortedEntries, by: \.type)
      .mapValues { group in
        DocType(name: group[0].type, count: group.count)
      }

    // Convert to JSON and sort the types by names
    let sortedTypesJSON = typesMap.values
      .sorted { sortNames($0.name, $1.name) }
      .map { $0.asJSON() }

    return [
      "entries": sortedEntries.map { $0.asJSON() },
      "types": sortedTypesJSON,
    ]
  }

  public func toJSON() throws -> Data {
    return try JSONSerialization.data(
      withJSONObject: asJSON(),
      options: .prettyPrinted
    )
  }

  private func sortNames(_ a: String, _ b: String) -> Bool {
    let aFirstByte = a.first?.asciiValue ?? 0
    let bFirstByte = b.first?.asciiValue ?? 0

    let aIsDigit = (49...57).contains(aFirstByte)
    let bIsDigit = (49...57).contains(bFirstByte)

    if aIsDigit || bIsDigit {
      let aSplit = a.components(separatedBy: CharacterSet(charactersIn: ".-"))
      let bSplit = b.components(separatedBy: CharacterSet(charactersIn: ".-"))

      if aSplit.count == 1 && bSplit.count == 1 {
        return a.localizedCaseInsensitiveCompare(b) == .orderedAscending
      }
      if aSplit.count == 1 { return false }
      if bSplit.count == 1 { return true }

      return a.localizedCaseInsensitiveCompare(b) == .orderedAscending
    } else {
      return a.localizedCaseInsensitiveCompare(b) == .orderedAscending
    }
  }
}
// Contains the logic for the storing... Docs!! This is going to handle the composition
// Of all of the important doc information... think index, meta, and content, into the
// formats they're expected to be.

import Foundation
import Logging

public protocol DocStorerProtocol {
  func store(_ doc: Doc, to store: DocumentStore) async throws
}

/// The default implementation for doc storage
public struct DocStorer: DocStorerProtocol {
  private let logger: Logger

  public init(logger: Logger = Logger(label: "DocStorer")) {
    self.logger = logger
  }

  public func store(_ doc: Doc, to store: DocumentStore) async throws {
    // Get empty (mutable) stores to build on top of :)
    var index = EntryIndex()
    var pages = PageDatabase()

    // Process all pages
    for await page in doc.buildPages() {
      try await store.write(page.storePath, content: page.output)
      index.add(page.entries)
      pages.add(path: page.path, content: page.output)
    }

    // Write index.json
    let indexData = try index.toJSON()
    try await store.write(doc.indexPath, data: indexData)

    // Write db.json
    let dbData = try pages.toJSON()
    try await store.write(doc.dbPath, data: dbData)

    // Write meta.json
    var meta = doc.asJSON()
    meta["mtime"] = Int(Date().timeIntervalSince1970)
    meta["db_size"] = try await store.size(doc.dbPath)
    let metaData = try JSONSerialization.data(withJSONObject: meta, options: .prettyPrinted)
    try await store.write(doc.metaPath, data: metaData)

    logger.info("Successfully stored doc: \(doc.slug)")
  }
}
// Sources/NewDocs/Storage/DocumentStore.swift
// VERY GENERIC storage, designed to be interacted with through the docstorer, which handles the actual document-specific writing...

import Foundation

public protocol DocumentStore {
  func write(_ path: String, content: String) async throws
  func write(_ path: String, data: Data) async throws
  func read(_ path: String) async throws -> String
  func exists(_ path: String) async -> Bool
  func size(_ path: String) async throws -> Int
  func delete(_ path: String) async throws
  func list(_ directory: String) async throws -> [String]
}

public struct FileSystemStore: DocumentStore {
  private let baseDirectory: URL

  public init(baseDirectory: String) throws {
    self.baseDirectory = URL(fileURLWithPath: baseDirectory)
    try createDirectoryIfNeeded()
  }

  private func createDirectoryIfNeeded() throws {
    try FileManager.default.createDirectory(
      at: baseDirectory,
      withIntermediateDirectories: true,
      attributes: nil
    )
  }

  /// Convenience function to write string contents to the specified path
  public func write(_ path: String, content: String) async throws {
    try await write(path, data: content.data(using: .utf8) ?? Data())
  }

  /// Convenience function to write data to the specificed path
  public func write(_ path: String, data: Data) async throws {
    let fileURL = baseDirectory.appendingPathComponent(path)
    let directoryURL = fileURL.deletingLastPathComponent()

    // Creates directories as necessary up to the component
    try FileManager.default.createDirectory(
      at: directoryURL,
      withIntermediateDirectories: true,
      attributes: nil
    )

    try data.write(to: fileURL)
  }

  public func read(_ path: String) async throws -> String {
    let fileURL = baseDirectory.appendingPathComponent(path)
    let data = try Data(contentsOf: fileURL)
    guard let content = String(data: data, encoding: .utf8) else {
      throw DocsError.parsingError("Could not decode file as UTF-8: \(path)")
    }
    return content
  }

  public func exists(_ path: String) async -> Bool {
    let fileURL = baseDirectory.appendingPathComponent(path)
    return FileManager.default.fileExists(atPath: fileURL.path)
  }

  public func size(_ path: String) async throws -> Int {
    let fileURL = baseDirectory.appendingPathComponent(path)
    let attributes = try FileManager.default.attributesOfItem(atPath: fileURL.path)
    return (attributes[.size] as? Int) ?? 0
  }

  public func delete(_ path: String) async throws {
    let fileURL = baseDirectory.appendingPathComponent(path)
    try FileManager.default.removeItem(at: fileURL)
  }

  public func list(_ directory: String) async throws -> [String] {
    let directoryURL = baseDirectory.appendingPathComponent(directory)
    return try FileManager.default.contentsOfDirectory(atPath: directoryURL.path)
  }
}
import Foundation

public enum DocsError: Error, CustomStringConvertible {
  case setupError(String)
  case invalidEntry(String)
  case networkError(String)
  case parsingError(String)
  case fileNotFound(String)
  case invalidConfiguration(String)

  public var description: String {
    switch self {
    case .setupError(let message): return "Setup Error: \(message)"
    case .invalidEntry(let message): return "Invalid Entry: \(message)"
    case .networkError(let message): return "Network Error: \(message)"
    case .parsingError(let message): return "Parsing Error: \(message)"
    case .fileNotFound(let message): return "File Not Found: \(message)"
    case .invalidConfiguration(let message): return "Invalid Configuration: \(message)"
    }
  }
}
import Foundation
import Logging
import SwiftSoup

public protocol HTMLParsing {
  var title: String? { get }
  var document: Document { get }
}

public struct HTMLParser: HTMLParsing {
  public let title: String?
  public let document: Document

  public init(_ content: String) throws {
    // Detect if the HTML contains the full prelude string
    if content.range(
      of: #"(?i)\A(?:\s|(?:<!--.*?-->))*<(?:\!doctype|html)"#, options: .regularExpression) != nil
    {
      document = try SwiftSoup.parse(content)
      title = try document.select("title").first()?.text()
    } else {  // If not, assume it's a fragment and treat it as such.
      document = try SwiftSoup.parseBodyFragment(content)
      title = nil
    }
  }
}
import Foundation
import Logging
import SemVer

public enum OutdatedState: String, CaseIterable {
  case upToDate = "Up-to-date"
  case outdatedMinor = "Outdated minor version"
  case outdatedMajor = "Outdated major version"
}

public protocol Doc: Instrumentable {
  var name: String { get }  // The name you'd expect to see it referred to as
  var slug: String { get }  // The battle-ready slug for encoding and references
  var type: String { get }
  var version: Version? { get }  // The latest version we're aware of in the "software"
  var links: [String: URL] { get }

  func buildPages() -> AsyncStream<PageResult>
  func getLatestVersion() async throws -> String
  func getScraperVersion() async throws -> String
}

extension Doc {
  /// Returns the typical pathing for an index
  public var indexPath: String {
    return "\(slug)/index.json"
  }

  /// Returns the typical pathing for a DB
  public var dbPath: String {
    return "\(slug)/db.json"
  }

  /// Returns the typicalR pathing for the meta files
  public var metaPath: String {
    return "\(slug)/meta.json"
  }

  /// Returns the Doc as a JSONL object
  public func asJSON() -> [String: Any] {
    var json: [String: Any] = [
      "name": name,
      "slug": slug,
      "type": type,
    ]

    if !links.isEmpty {
      json["links"] = links
    }

    if let release = version {
      json["release"] = release
    }

    return json
  }

  // Utility methods for network requests
  public func fetchJSON(from urlString: String) async throws -> [String: Any] {
    let request = HTTPRequest(logger: logger)
    let response = try await request.request(urlString)
    guard response.isSuccess else {
      throw DocsError.networkError("Failed to fetch \(urlString): \(response.statusCode)")
    }
    return try response.asJSON()
  }

  public func getNPMVersion(package: String, tag: String = "latest") async throws -> String {
    let json = try await fetchJSON(from: "https://registry.npmjs.com/\(package)")
    guard let distTags = json["dist-tags"] as? [String: Any],
      let version = distTags[tag] as? String
    else {
      throw DocsError.parsingError("Could not parse npm version for \(package)")
    }
    return version
  }

  public func getLatestGitHubRelease(owner: String, repo: String) async throws -> String {
    let json = try await fetchJSON(
      // Getting the release endpoint
      from: "https://api.github.com/repos/\(owner)/\(repo)/releases/latest")
    guard let tagName = json["tag_name"] as? String else {
      throw DocsError.parsingError("Could not parse GitHub release tag")
    }
    return tagName.hasPrefix("v") ? String(tagName.dropFirst()) : tagName
  }
}
import Foundation

public protocol PageDatabaseProtocol {
  var isEmpty: Bool { get }

  mutating func add(path: String, content: String)
  func asJSON() -> [String: Any]
  func toJSON() throws -> Data
}

public struct PageDatabase: PageDatabaseProtocol {
  private var pages: [String: String] = [:]

  public init() {}

  public var isEmpty: Bool {
    return pages.isEmpty
  }

  public mutating func add(path: String, content: String) {
    pages[path] = content
  }

  public func asJSON() -> [String: Any] {
    return pages
  }

  public func toJSON() throws -> Data {
    return try JSONSerialization.data(withJSONObject: asJSON(), options: [])
  }
}
// Filtering for an HTML document, meant to be used to reduce unwanted structure.
// Think ads, nesting, etc. Basically an interface to build helpers ontop of,
// to pare down a messy document. Allows us to create simple methods that are universally useful,
// Like normalizing URLS :)

import Foundation
import Logging
import SwiftSoup

public protocol Filter {
  func apply(to document: Document, context: FilterContext) throws -> Document
}

public struct FilterContext {
  public let baseURL: DocsURL
  public let currentURL: DocsURL
  public let rootURL: DocsURL
  public let rootPath: String?
  public let links: [String: URL]
  public let initialPaths: [String]
  public let logger: Logger

  public init(
    baseURL: DocsURL,
    currentURL: DocsURL,
    rootURL: DocsURL,
    rootPath: String? = nil,
    links: [String: URL] = [:],
    initialPaths: [String] = [],
    logger: Logger = Logger(label: "Filter")
  ) {
    self.baseURL = baseURL
    self.currentURL = currentURL
    self.rootURL = rootURL
    self.rootPath = rootPath
    self.links = links
    self.initialPaths = initialPaths
    self.logger = logger
  }

  public var subpath: String {
    return baseURL.subpath(to: currentURL, ignoreCase: true) ?? ""
  }

  public var slug: String {
    let path = subpath.hasPrefix("/") ? String(subpath.dropFirst()) : subpath
    return path.replacingOccurrences(of: ".html", with: "")
  }

  public var isRootPage: Bool {
    return subpath.isEmpty || subpath == "/" || subpath == rootPath
  }

  public var isInitialPage: Bool {
    return isRootPage || initialPaths.contains(subpath)
  }
}

public protocol FilterStacking {
  mutating func push(_ filter: Filter)
  func apply(to document: Document, context: FilterContext) throws -> Document
}

public struct FilterStack: FilterStacking {
  private var filters: [Filter] = []

  public init() {}

  public mutating func push(_ filter: Filter) {
    filters.append(filter)
  }

  public func apply(to document: Document, context: FilterContext) throws -> Document {
    var currentDocument = document
    for filter in filters {
      currentDocument = try filter.apply(to: currentDocument, context: context)
    }
    return currentDocument
  }
}
import Foundation

public struct DocsURL: Equatable, Hashable {
  public let url: URL

  public init(_ string: String) throws {
    guard let url = URL(string: string) else {
      throw DocsError.invalidConfiguration("Invalid URL: \(string)")
    }
    self.url = url
  }

  public init(_ url: URL) {
    self.url = url
  }

  public var origin: String? {
    guard let scheme = url.scheme, let host = url.host else { return nil }
    var origin = "\(scheme)://\(host)"
    if let port = url.port {
      origin += ":\(port)"
    }
    return origin
  }

  public var normalizedPath: String {
    return url.path.isEmpty ? "/" : url.path
  }

  public func subpath(to other: DocsURL, ignoreCase: Bool = false) -> String? {
    guard origin == other.origin else { return nil }

    let basePath = ignoreCase ? url.path.lowercased() : url.path
    let destPath = ignoreCase ? other.url.path.lowercased() : other.url.path

    if basePath == destPath {
      return ""
    } else if destPath.hasPrefix(basePath + "/") {
      return String(other.url.path.dropFirst(url.path.count))
    }
    return nil
  }

  public func contains(_ other: DocsURL, ignoreCase: Bool = false) -> Bool {
    return subpath(to: other, ignoreCase: ignoreCase) != nil
  }

  public func joining(_ path: String) -> DocsURL {
    let newURL = url.appendingPathComponent(path)
    return DocsURL(newURL)
  }
}

extension DocsURL: CustomStringConvertible {
  public var description: String {
    return url.absoluteString
  }
}
import Foundation

public struct ScraperOptions {
  public var skip: [String]
  public var skipPatterns: [NSRegularExpression]
  public var only: [String]
  public var onlyPatterns: [NSRegularExpression]
  public var skipLinks: [String]
  public var fixedInternalUrls: Bool
  public var redirections: [String: String]
  public var rateLimit: Int?
  public var maxConcurrency: Int
  public var timeout: TimeInterval
  public var retryCount: Int
  public var fixURLs: ((String) -> String)?
  public var attribution: String?
  public var version: String?
  public var release: String?
  public var links: [String: String]

  public init(
    skip: [String] = [],
    skipPatterns: [NSRegularExpression] = [],
    only: [String] = [],
    onlyPatterns: [NSRegularExpression] = [],
    skipLinks: [String] = [],
    fixedInternalUrls: Bool = false,
    redirections: [String: String] = [:],
    rateLimit: Int? = nil,
    maxConcurrency: Int = 20,
    timeout: TimeInterval = 30,
    retryCount: Int = 3,
    fixURLs: ((String) -> String)? = nil,
    attribution: String? = nil,
    version: String? = nil,
    release: String? = nil,
    links: [String: String] = [:]
  ) {
    self.skip = skip
    self.skipPatterns = skipPatterns
    self.only = only
    self.onlyPatterns = onlyPatterns
    self.skipLinks = skipLinks
    self.fixedInternalUrls = fixedInternalUrls
    self.redirections = redirections
    self.rateLimit = rateLimit
    self.maxConcurrency = maxConcurrency
    self.timeout = timeout
    self.retryCount = retryCount
    self.fixURLs = fixURLs
    self.attribution = attribution
    self.version = version
    self.release = release
    self.links = links
  }
}
import Foundation

public struct Entry: Codable, Equatable, Hashable {
  public let name: String  // Semnatic name for the doc (std::time)
  public let path: String  // The location of the doc (rust/std/time)
  public let type: String  // The kind of documentation (module, class, etc.)

  public init(name: String, path: String, type: String) throws {
    let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
    let trimmedPath = path.trimmingCharacters(in: .whitespacesAndNewlines)
    let trimmedType = type.trimmingCharacters(in: .whitespacesAndNewlines)

    guard !trimmedName.isEmpty else {
      throw DocsError.invalidEntry("missing name")
    }
    guard !trimmedPath.isEmpty else {
      throw DocsError.invalidEntry("missing path")
    }
    guard !trimmedType.isEmpty else {
      throw DocsError.invalidEntry("missing type")
    }

    self.name = trimmedName
    self.path = trimmedPath
    self.type = trimmedType
  }

  public var isRoot: Bool {
    return path == "index"
  }

  public func asJSON() -> [String: Any] {
    return [
      "name": name,
      "path": path,
      "type": type,
    ]
  }
}
import Foundation

public protocol ManifestProtocol {
  func generate(docs: [Doc], store: DocumentStore) async throws
}

public struct Manifest: ManifestProtocol {
  private static let filename = "docs.json"

  public init() {}

  public func generate(docs: [Doc], store: DocumentStore) async throws {
    let jsonData = try await toJSON(docs: docs, store: store)
    try await store.write(Self.filename, data: jsonData)
  }

  private func asJSON(docs: [Doc], store: DocumentStore) async throws -> [[String: Any]] {
    var result: [[String: Any]] = []

    for doc in docs {
      guard await store.exists(doc.metaPath) else { continue }

      let metaContent = try await store.read(doc.metaPath)
      guard let metaData = metaContent.data(using: .utf8),
        var json = try JSONSerialization.jsonObject(with: metaData) as? [String: Any]
      else {
        continue
      }

      result.append(json)
    }

    return result
  }

  private func toJSON(docs: [Doc], store: DocumentStore) async throws -> Data {
    let jsonObject = try await asJSON(docs: docs, store: store)
    return try JSONSerialization.data(withJSONObject: jsonObject, options: .prettyPrinted)
  }
}
